[{"name": "app.py", "content": "import ipyleaflet as L\nfrom faicons import icon_svg\nfrom geopy.distance import geodesic, great_circle\nfrom shared import BASEMAPS, CITIES\nfrom shiny import reactive\nfrom shiny.express import input, render, ui\nfrom shinywidgets import render_widget\n\ncity_names = sorted(list(CITIES.keys()))\n\nui.page_opts(title=\"Location Distance Calculator\", fillable=True)\n{\"class\": \"bslib-page-dashboard\"}\n\nwith ui.sidebar():\n    ui.input_selectize(\"loc1\", \"Location 1\", choices=city_names, selected=\"New York\")\n    ui.input_selectize(\"loc2\", \"Location 2\", choices=city_names, selected=\"London\")\n    ui.input_selectize(\n        \"basemap\",\n        \"Choose a basemap\",\n        choices=list(BASEMAPS.keys()),\n        selected=\"WorldImagery\",\n    )\n    ui.input_dark_mode(mode=\"dark\")\n\nwith ui.layout_column_wrap(fill=False):\n    with ui.value_box(showcase=icon_svg(\"globe\"), theme=\"gradient-blue-indigo\"):\n        \"Great Circle Distance\"\n\n        @render.text\n        def great_circle_dist():\n            circle = great_circle(loc1xy(), loc2xy())\n            return f\"{circle.kilometers.__round__(1)} km\"\n\n    with ui.value_box(showcase=icon_svg(\"ruler\"), theme=\"gradient-blue-indigo\"):\n        \"Geodisic Distance\"\n\n        @render.text\n        def geo_dist():\n            dist = geodesic(loc1xy(), loc2xy())\n            return f\"{dist.kilometers.__round__(1)} km\"\n\n    with ui.value_box(showcase=icon_svg(\"mountain\"), theme=\"gradient-blue-indigo\"):\n        \"Altitude Difference\"\n\n        @render.text\n        def altitude():\n            try:\n                return f'{loc1()[\"altitude\"] - loc2()[\"altitude\"]} m'\n            except TypeError:\n                return \"N/A (altitude lookup failed)\"\n\n\nwith ui.card():\n    ui.card_header(\"Map (drag the markers to change locations)\")\n\n    @render_widget\n    def map():\n        return L.Map(zoom=4, center=(0, 0))\n\n\n# Reactive values to store location information\nloc1 = reactive.value()\nloc2 = reactive.value()\n\n\n# Update the reactive values when the selectize inputs change\n@reactive.effect\ndef _():\n    loc1.set(CITIES.get(input.loc1(), loc_str_to_coords(input.loc1())))\n    loc2.set(CITIES.get(input.loc2(), loc_str_to_coords(input.loc2())))\n\n\n# When a marker is moved, the input value gets updated to \"lat, lon\",\n# so we decode that into a dict (and also look up the altitude)\ndef loc_str_to_coords(x: str) -> dict:\n    latlon = x.split(\", \")\n    if len(latlon) != 2:\n        return {}\n\n    lat = float(latlon[0])\n    lon = float(latlon[1])\n\n    try:\n        import requests\n\n        query = f\"https://api.open-elevation.com/api/v1/lookup?locations={lat},{lon}\"\n        r = requests.get(query).json()\n        altitude = r[\"results\"][0][\"elevation\"]\n    except Exception:\n        altitude = None\n\n    return {\"latitude\": lat, \"longitude\": lon, \"altitude\": altitude}\n\n\n# Convenient way to get the lat/lons as a tuple\n@reactive.calc\ndef loc1xy():\n    return loc1()[\"latitude\"], loc1()[\"longitude\"]\n\n\n@reactive.calc\ndef loc2xy():\n    return loc2()[\"latitude\"], loc2()[\"longitude\"]\n\n\n# Add marker for first location\n@reactive.effect\ndef _():\n    update_marker(map.widget, loc1xy(), on_move1, \"loc1\")\n\n\n# Add marker for second location\n@reactive.effect\ndef _():\n    update_marker(map.widget, loc2xy(), on_move2, \"loc2\")\n\n\n# Add line and fit bounds when either marker is moved\n@reactive.effect\ndef _():\n    update_line(map.widget, loc1xy(), loc2xy())\n\n\n# If new bounds fall outside of the current view, fit the bounds\n@reactive.effect\ndef _():\n    l1 = loc1xy()\n    l2 = loc2xy()\n\n    lat_rng = [min(l1[0], l2[0]), max(l1[0], l2[0])]\n    lon_rng = [min(l1[1], l2[1]), max(l1[1], l2[1])]\n    new_bounds = [\n        [lat_rng[0], lon_rng[0]],\n        [lat_rng[1], lon_rng[1]],\n    ]\n\n    b = map.widget.bounds\n    if len(b) == 0:\n        map.widget.fit_bounds(new_bounds)\n    elif (\n        lat_rng[0] < b[0][0]\n        or lat_rng[1] > b[1][0]\n        or lon_rng[0] < b[0][1]\n        or lon_rng[1] > b[1][1]\n    ):\n        map.widget.fit_bounds(new_bounds)\n\n\n# Update the basemap\n@reactive.effect\ndef _():\n    update_basemap(map.widget, input.basemap())\n\n\n# ---------------------------------------------------------------\n# Helper functions\n# ---------------------------------------------------------------\n\n\ndef update_marker(map: L.Map, loc: tuple, on_move: object, name: str):\n    remove_layer(map, name)\n    m = L.Marker(location=loc, draggable=True, name=name)\n    m.on_move(on_move)\n    map.add_layer(m)\n\n\ndef update_line(map: L.Map, loc1: tuple, loc2: tuple):\n    remove_layer(map, \"line\")\n    map.add_layer(\n        L.Polyline(locations=[loc1, loc2], color=\"blue\", weight=2, name=\"line\")\n    )\n\n\ndef update_basemap(map: L.Map, basemap: str):\n    for layer in map.layers:\n        if isinstance(layer, L.TileLayer):\n            map.remove_layer(layer)\n    map.add_layer(L.basemap_to_tiles(BASEMAPS[input.basemap()]))\n\n\ndef remove_layer(map: L.Map, name: str):\n    for layer in map.layers:\n        if layer.name == name:\n            map.remove_layer(layer)\n\n\ndef on_move1(**kwargs):\n    return on_move(\"loc1\", **kwargs)\n\n\ndef on_move2(**kwargs):\n    return on_move(\"loc2\", **kwargs)\n\n\n# When the markers are moved, update the selectize inputs to include the new\n# location (which results in the locations() reactive value getting updated,\n# which invalidates any downstream reactivity that depends on it)\ndef on_move(id, **kwargs):\n    loc = kwargs[\"location\"]\n    loc_str = f\"{loc[0]}, {loc[1]}\"\n    choices = city_names + [loc_str]\n    ui.update_selectize(id, selected=loc_str, choices=choices)", "type": "text"}, {"name": "shared.py", "content": "from ipyleaflet import basemaps\n\nBASEMAPS = {\n    \"WorldImagery\": basemaps.Esri.WorldImagery,\n    \"Mapnik\": basemaps.OpenStreetMap.Mapnik,\n    \"Positron\": basemaps.CartoDB.Positron,\n    \"DarkMatter\": basemaps.CartoDB.DarkMatter,\n    \"NatGeoWorldMap\": basemaps.Esri.NatGeoWorldMap,\n    \"France\": basemaps.OpenStreetMap.France,\n    \"DE\": basemaps.OpenStreetMap.DE,\n}\n\n\nCITIES = {\n    \"New York\": {\"latitude\": 40.7128, \"longitude\": -74.0060, \"altitude\": 33},\n    \"London\": {\"latitude\": 51.5074, \"longitude\": -0.1278, \"altitude\": 36},\n    \"Paris\": {\"latitude\": 48.8566, \"longitude\": 2.3522, \"altitude\": 35},\n    \"Tokyo\": {\"latitude\": 35.6895, \"longitude\": 139.6917, \"altitude\": 44},\n    \"Sydney\": {\"latitude\": -33.8688, \"longitude\": 151.2093, \"altitude\": 39},\n    \"Los Angeles\": {\"latitude\": 34.0522, \"longitude\": -118.2437, \"altitude\": 71},\n    \"Berlin\": {\"latitude\": 52.5200, \"longitude\": 13.4050, \"altitude\": 34},\n    \"Rome\": {\"latitude\": 41.9028, \"longitude\": 12.4964, \"altitude\": 21},\n    \"Beijing\": {\"latitude\": 39.9042, \"longitude\": 116.4074, \"altitude\": 44},\n    \"Moscow\": {\"latitude\": 55.7558, \"longitude\": 37.6176, \"altitude\": 156},\n    \"Cairo\": {\"latitude\": 30.0444, \"longitude\": 31.2357, \"altitude\": 23},\n    \"Rio de Janeiro\": {\"latitude\": -22.9068, \"longitude\": -43.1729, \"altitude\": 8},\n    \"Toronto\": {\"latitude\": 43.6511, \"longitude\": -79.3832, \"altitude\": 76},\n    \"Dubai\": {\"latitude\": 25.2769, \"longitude\": 55.2963, \"altitude\": 52},\n    \"Mumbai\": {\"latitude\": 19.0760, \"longitude\": 72.8777, \"altitude\": 14},\n    \"Seoul\": {\"latitude\": 37.5665, \"longitude\": 126.9780, \"altitude\": 38},\n    \"Madrid\": {\"latitude\": 40.4168, \"longitude\": -3.7038, \"altitude\": 667},\n    \"Amsterdam\": {\"latitude\": 52.3676, \"longitude\": 4.9041, \"altitude\": -2},\n    \"Buenos Aires\": {\"latitude\": -34.6037, \"longitude\": -58.3816, \"altitude\": 25},\n    \"Stockholm\": {\"latitude\": 59.3293, \"longitude\": 18.0686, \"altitude\": 14},\n    \"Boulder\": {\"latitude\": 40.0150, \"longitude\": -105.2705, \"altitude\": 1634},\n    \"Lhasa\": {\"latitude\": 29.6500, \"longitude\": 91.1000, \"altitude\": 3650},\n    \"Khatmandu\": {\"latitude\": 27.7172, \"longitude\": 85.3240, \"altitude\": 1400},\n}", "type": "text"}]